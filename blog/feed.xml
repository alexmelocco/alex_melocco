<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="http://localhost:4000/blog/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/blog/" rel="alternate" type="text/html" /><updated>2024-12-05T15:20:55+11:00</updated><id>http://localhost:4000/blog/feed.xml</id><title type="html">Alex Melocco’s Blog</title><subtitle>Welcome to my blog! I love conducting research, buidling projects and sharing my findings with others. I hope you find my blog posts interesting and informative, and please reach out if you want to contribute or even critique!</subtitle><entry><title type="html">[Research Insights] Comparative Analysis of Financial Sentiment Models</title><link href="http://localhost:4000/blog/jekyll/update/2024/10/10/Comparitive-fin-sent-analysis.html" rel="alternate" type="text/html" title="[Research Insights] Comparative Analysis of Financial Sentiment Models" /><published>2024-10-10T16:13:45+11:00</published><updated>2024-10-10T16:13:45+11:00</updated><id>http://localhost:4000/blog/jekyll/update/2024/10/10/Comparitive-fin-sent-analysis</id><content type="html" xml:base="http://localhost:4000/blog/jekyll/update/2024/10/10/Comparitive-fin-sent-analysis.html"><![CDATA[<h1 id="comparative-analysis-of-financial-sentiment-models">Comparative Analysis of Financial Sentiment Models</h1>

<h2 id="table-of-contents">Table of Contents</h2>

<ol>
  <li><a href="#10-introduction">Introduction</a></li>
  <li><a href="#20-experimental-setup">Experimental Setup</a></li>
  <li><a href="#30-methods-used">Methods Used</a></li>
  <li><a href="#40-results-and-discussion">Results and Discussion</a></li>
  <li><a href="#41-effectiveness-of-selected-model">Effectiveness of Selected Model</a></li>
  <li><a href="#42-future-research-paths">Future Research Paths</a></li>
  <li><a href="#50-conclusion">Conclusion</a></li>
  <li><a href="#60-data-source">Data Source</a></li>
  <li><a href="#70-related-work-that-i-took-inspiration-from">Related Work that I took inspiration from</a></li>
</ol>

<h2 id="github-repository">GitHub Repository</h2>

<p>The code and additional resources for this project can be found in my GitHub repository: <a href="https://github.com/alexmelocco/alex_melocco/tree/main/FinancialSentimentAnalysisModelling">Financial Sentiment Analysis Modelling</a>.</p>

<h2 id="10-introduction">1.0 Introduction</h2>

<p>The financial market is susceptible to public sentiment, which can significantly influence stock prices and market trends. News headlines are vital information sources that sway investor behaviour. However, the sheer volume of news articles and social media posts generated daily makes it challenging to assess sentiment accurately and promptly manually, highlighting a need for an automated solution to process and analyse vast amounts of textual data quickly and efficiently.</p>

<p>Financial institutions and investors can significantly benefit from a sentiment analysis model that provides real-time insights into how the market is fluctuating. Such a tool can enhance investment strategies, improve risk management, and lead to better financial outcomes.</p>

<p>This report, researched and compiled by Alex Melocco, presents an analysis of different models’ performance in financial sentiment analysis. The primary objective is to evaluate and compare the effectiveness of various natural language processing models in classifying financial news into positive, neutral, or negative sentiments. The models examined include TextCNN, LSTM, Bi-GRU, VADER, and BERT. The analysis aims to identify the most suitable model for real-world applications in the financial sector, considering both accuracy and computational efficiency.</p>

<h3 id="11-motivations">1.1 Motivations</h3>

<p>The motivation for this project stems from the abundance of research papers covering financial sentiment analysis on extremely large datasets. I aimed to theorize the effectiveness of similar models in a less commercial environment, where access to resources is limited. Smaller datasets, especially with models such as BERT, can significantly affect performance. This research was conducted to address real-world NLP problems that lack access to large datasets, and to provide a comparison between models trained on large versus small datasets, which is crucial for understanding their practical applicability.</p>

<h2 id="20-experimental-setup">2.0 Experimental Setup</h2>

<p>The project uses the dataset constructed in the paper Good Debt or Bad Debt: Detecting Semantic Orientations in Economic Texts. The dataset consists of 4840 English language, each with an associated class of “positive”, “neutral”, or “negative”. Each label was chosen based on the consensus of up to 12 annotators Finland’s Aalto University School of Business. The dataset is then further segmented into subsets based on the number of annotators that agreed with a given label, the splits are presented below:</p>

<table>
  <thead>
    <tr>
      <th>Subset</th>
      <th>Number of Entries</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Sentences with 100% agreement</td>
      <td>2259</td>
    </tr>
    <tr>
      <td>Sentences with greater than 75% agreement</td>
      <td>3448</td>
    </tr>
    <tr>
      <td>Sentences with greater than 66% agreement</td>
      <td>4211</td>
    </tr>
    <tr>
      <td>Sentences with greater than 50% agreement</td>
      <td>4840</td>
    </tr>
  </tbody>
</table>

<p>This project uses the “Greater than 50%” split in order to maximize training data and expose the model to a dataset more representative of real world data. The dataset can be found <a href="https://huggingface.co/datasets/takala/financial_phrasebank">here</a>.</p>

<p>As the dataset does not contain specifically separated test and validation data, during preprocessing the dataset is split into train, test and validation data in an 80:10:10 ratio, to maximise training data. The success of a given model is evaluated on the accuracy of the trained model over the test dataset.</p>

<p>This dataset presents several challenges for training a model. Beyond the clear lack of data, the dataset has a significant class imbalance, featuring nearly five times as many neutral data items as negative ones. This initially led models to appear as though they were suffering from severe overfitting, when in reality it was a symptom of this class imbalance. After altering the data item distribution such that the splits were created with even proportions of labels, this problem was eliminated.</p>

<p>While some hyperparameters varied between models, a number were decided and maintained across all. Batch size was set to 50, learning rate to 0.001, and the maximum number of epochs to 20.</p>

<h2 id="30-methods-used">3.0 Methods Used</h2>

<p>This project utilised an exploration of five alternate methods of addressing financial sentiment classification. This objective was to evaluate the usability, effectivenss and performance of different models in accurately classifying sentiment with financial texts. This was also in the context of data set limitations, where low levels of data were available to train data on (approx. 5000). By leveraging a diverse range of methodologies, I aimed to identify the strengths and weaknesses of each approach in the contextual limitations, thus proving comprehensive insight into the optimal techniques for financial sentiment analysis. The methods included VADER (Valence Aware Dictionary and Sentiment Reasoner), BERT (Bidirectional Encoder Representations from Transformers), Bi-GRU (Bidirectional Gated Recurrent Unit), Text CNN (Convolutional Neural Networks) and LSTM (Long Short-Term Memory), each chosen for their unique structure and application to natural language processing tasks. The following paragraphs outline the
efficacy of each model used.</p>

<p>LSTM was employed to capture the sequential dependencies in financial texts, where the ability to retain information over long sequences is particularly beneficial for sentiment analysis, as sentiment is often derived from the context rather than individual words. the team implemented LSTM through the TensorFlow library, utilizing its recurrent architecture to effectively process and analyse the sentiment of financial statements. To address overfitting, I employed various regularization techniques such as early stopping, extensive dropout layers, and kernel regularization. Data augmentation was also attempted using the NLTK library to create more data through techniques like synonym replacement, deletion, insertion, and back-translation. However, these augmentation techniques often failed to preserve the original sentiment, leading to mixed results. Despite the challenges, a balance was found between regularization techniquesbert</p>

<p>The TextCNN model employs a simple, yet effective architecture designed for sentence classification. The model starts with an embedding layer, where each word in a sentence is represented as a dense vector of fixed size. These embeddings capture semantic information and serve as the input to the convolutional layers. The model uses multiple convolutional layers with different filter sizes to extract various n-gram features from the sentence. Each convolutional layer applies filters that slide over the input embeddings, producing feature maps highlighting important local patterns.Max-pooling layers follow the convolutional layers, selecting the most salient features from each feature map, thus reducing the dimensionality and focusing on the most critical information.</p>

<p>BERT reads text in both directions to understand context. It is applied to various tasks such as text classification, question answering, and named entity recognition. Embeddings are very important for the processing and understanding of the input text in BERT. Following are three embedding types:</p>

<ul>
  <li>Token Embeddings: This is the representation of every single token, whether words or sub-words in the input text.</li>
  <li>Positional Embeddings: Since transformers do not know about the order of tokens, positional embeddings are used for encoding the position of each token in the sequence. These are embeddings that enable a model to consider an order of words, which is relevant in understanding context.</li>
  <li>Segment Embeddings: To differentiate the two different sentences for next-sentence prediction tasks or other paired-sentence tasks, segment embeddings are used. Tokens of the first sentence receive one type of embeddings, usually all zeros, and tokens of the second, usually all ones.</li>
</ul>

<p>These embeddings allow BERT to learn an understanding of the context and meaning of language; at its complexity— some 110 million parameters—it can be fine-tuned to do tasks such as sentiment analysis. Part of what makes Bert so powerful is its inbuilt optimization, with features such as drop out layers, regularization and weight decay the model can learn more efficiently thus using this model effectively involved using varying hyper parameters to achieve the best result.</p>

<p>A Gated Recurrent Unit has very similar architecture to an LSTM, with the absence of the cell gate, making it computationally faster. A Bi-directional GRU is comprised of two GRUs running parallel and inverse to one another up and down a sentence. In this way, each unit in Bi-GRU incorporates context from the previous and next word, making it highly suited as a lightweight NLP tool.</p>

<p>VADER (Valence Aware Dictionary and sEntiment Reader) is a pretrained, publicly available sentiment analysis model which claims to be effective in a range of scenarios, including financial texts. It was included in this</p>

<h2 id="40-results-and-discussion">4.0 Results and Discussion</h2>

<p>By comparing the output of multiple models, it is clear that under these conditions TextCNN performs the best. This is a somewhat unexpected outcome, as many of the available academic papers on the subject of natural language processing indicate BERT as the most successful model. This report argues that BERT was kneecapped in this particular scenario by the lack of available training data. Natural Language Processing models are most effective when given significant amounts of training data, as semantic and contextual patterns become more apparent. BERT specifically is designed to learn the contextual connections between words, and likely struggled with such a small dataset. Comparatively, the relatively simpler models TextCNN and Bi-GRU thrived, as they could more quickly determine and mark individual words with high semantic value.</p>

<p>In regards to performance, TextCNN, Bi-GRU and LSTM are all lightweight models that can be trained quickly and classify test data fast. This is owed in part to the small vocabulary of 11258 unique words and the relatively short sentences. The longest sentence present in the dataset was 52 words, and all others were padded with leading zeroes to match. Conversely, BERT, with its 110 million trainable parameters, is computationally expensive, especially when without access to a GPU.</p>

<p>Below is the table of models in this report scored by accuracy. Note that the accuracy of VADER in particular should not be taken as a measure of its success, for reasons explored in the VADER Results section above.</p>

<table>
  <thead>
    <tr>
      <th>Model</th>
      <th>Accuracy</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>TextCNN</td>
      <td>76.5%</td>
    </tr>
    <tr>
      <td>LSTM</td>
      <td>67.0%</td>
    </tr>
    <tr>
      <td>Bi-GRU</td>
      <td>66.8%</td>
    </tr>
    <tr>
      <td>VADER</td>
      <td>59.0%*</td>
    </tr>
    <tr>
      <td>BERT</td>
      <td>8.5%</td>
    </tr>
  </tbody>
</table>

<h3 id="41-effectiveness-of-selected-model">4.1 Effectiveness of Selected Model</h3>

<p>With an accuracy of 76.5%, I believe the TextCNN model would be effective in a real-world scenario. The model was intentionally trained on the “greater than 50% agreement” data split in order to expose it to as much contentious, real-world data as possible. The model I’ve developed is highly specialized for its domain, and far surpasses general use models like VADER. When comparing it to the results achieved in “<strong>Good Debt or Bad Debt: Detecting Semantic Orientations in Economic Texts</strong>”, which uses the same dataset, I find TextCNN falls short of the 85.8% achieved by the team, approximately a 10% drop in efficacy, possibly resulting from the simpler architecture of TextCNN. However, I still believe that the model is accurate enough to be useful in long-term classifications and trend analysis in the financial space.</p>

<p>This conclusion is based on results and should be taken with a grain of salt, with some important considerations that may have dictated the results including:</p>

<ul>
  <li>Relatively small data set</li>
</ul>

<p>With a larger dataset, i would theorise the result would be different, but that will be an interesting project to pursue in the future.</p>

<h3 id="42-future-research-paths">4.2 Future Research Paths</h3>

<p>There are a number of paths that I undertook to improve the performance of the model but through difficulty or time constraints were unable to complete. These would be excellent avenues for future research.</p>

<p>The first technique examined was the possibility of augmenting pre-existing data items to generate new ‘virtual’ data items that would still be semantically consistent. I significantly explored this technique, and the code used to generate the virtual items can be found further up this notebook. the technique involved replacing arbitrary words in sentences with synonyms pulled from a thesaurus dataset. For instance, the sentence fragment “This is great!” might be used to generate the new virtual sentence fragment “This is amazing!”. In this way, a new data item has been generated with the same semantic label of “positive”. However, in practice, I found the synonym replacement was overzealous. In one particular instance, it replaced the sentence fragment “… this sentence is…” with the fragment “…this condemn is…”. While condemn is a valid synonym for sentence, the program’s lack of contextual understanding has created an incorrect sentence. With further work, this technique could produce usable results, but due to time constraints, it was unfortunately shelved.</p>

<p>Another technique for future research is ensembling. As the project consists of a number of varying models, ensembling all or some of the models has promise in producing more accurate results. However, owing to the extreme variance in accuracy between models, I reached the conclusion that I couldn’t guarantee the effectiveness of an ensembled approach. This technique could be revisited after more effective models are implemented.</p>

<h2 id="50-conclusion">5.0 Conclusion</h2>

<p>The key strength of my proposed solution is its lightweight nature. TextCNN is easy to train and can predict far quicker than heavier models like BERT, while achieving a reasonable accuracy. My study was largely limited by the lack of available training data and the class imbalance. I explored a number of potential solutions to this, but saw little success. My main effort was in the development of an augmentation function with which to generate artificial data items. This would have been achieved through replacement of arbitrary words with semantically similar ones, such that a new sentence is generated with the same overall sentiment. In practice, this was hampered by my replacement function not accounting for context. For instance, the sentence fragment “This sentence is” was replaced with “This condemn is.” While sentence and condemn are synonyms, the context is lost and the sentence is unusable as training data. With more time this approach could be refined to produce better results. I also intended to devote time to researching possible ensemble learning approaches that could leverage my wide variety of models, but a lack of time and sporadic accuracy across models made this infeasible.</p>

<h2 id="60-data-source">6.0 Data Source</h2>

<p>The data is sourced from a 2013 study into Semantic Analysis of financial news; <strong>Good Debt or Bad Debt: Detecting Semantic Orientations in Economic Texts</strong>. The dataset is comprised of 4840 English sentences, each associated with a label “positive”, “neutral” or “negative”. The dataset has no explicitly separate test data, so in the model I will use a random selection of 80% of the data for training, 10% for testing and 10% for validation. Hence, the training dataset will comprise of 3872 data entries, and the test and validation sets will consist of 484 data entries each.</p>

<p>The dataset can be accessed <a href="https://huggingface.co/datasets/takala/financial_phrasebank">here</a>, and the paper from which the dataset originates can be accessed <a href="https://arxiv.org/abs/1307.5336">here</a>.</p>

<h2 id="70-related-work-that-i-took-inspiration-from">7.0 Related Work that I took inspiration from</h2>

<p>Convolutional Neural Networks for Sentence Classification by Kim Yoon (https://aclanthology.org/D14-1181): Kim Yoon’s paper demonstrates the potential of CNNs for sentence classification tasks, highlighting their simplicity and effectiveness. While the model achieves impressive results, it also has limitations related to data dependency, contextual information, and hyperparameter sensitivity. this method will look to be tested on a finance sentiment task.</p>

<p>Good Debt or Bad Debt: Detecting Semantic Orientations in Economic Texts by Pekka Malo, Ankur Sinha, Pyry Takala, Pekka Korhonen, Jyrki Wallenius (https://arxiv.org/abs/1307.5336): This paper is the source of the project’s dataset, and examines the use of Linearized Phrase Structure (LSP) in mapping groupings of words to contextual phrases and evaluating this new data, not dissimilar to convolution in image processing. This paper is
more than a decade old and has been superseded by modern advancements, particularly BERT.</p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[Comparative Analysis of Financial Sentiment Models]]></summary></entry><entry><title type="html">[Project Insights] Writing a Neural Network from scratch using Numpy</title><link href="http://localhost:4000/blog/jekyll/update/2024/02/02/Custom-neural-network.html" rel="alternate" type="text/html" title="[Project Insights] Writing a Neural Network from scratch using Numpy" /><published>2024-02-02T16:13:45+11:00</published><updated>2024-02-02T16:13:45+11:00</updated><id>http://localhost:4000/blog/jekyll/update/2024/02/02/Custom-neural-network</id><content type="html" xml:base="http://localhost:4000/blog/jekyll/update/2024/02/02/Custom-neural-network.html"><![CDATA[<h1 id="custom-neural-network-library---implements-handwritten-digit-recognition">Custom Neural Network Library - Implements Handwritten Digit Recognition</h1>

<p><a href="https://github.com/alexmelocco/alex_melocco/tree/main/HandwrittenDigitRecognition">GitHub Repository</a></p>

<p>Complete and custom Neural Network library architecture that is modular to any input/output specifications. Can be used similar to how TensorFlow Neural Networks are put together (documented). I have implemented a neural network that can recognise handwritten Digits to 97% accuracy. Current architecture only has Dense layers, but future plans to add more layers (convolutional, etc). This has complete modularity so you can add as many hidden layers as needed.</p>

<p>Currently, modeled to implement a custom handwritten digit recognition algorithm without the use of libaries such as Tensorflow or Pytorch (purely my own library). Numpy is going to be used for vectorization.</p>

<ul>
  <li>all (lossfunctions, calculation, derivatives etc) are done manually with no assistance from libraries</li>
  <li>Everything is custom - no functions borrowed from external sources (except MNIST data loader and graphing)</li>
</ul>

<p>Note: current <a href="main.ipynb">juypter notebook</a> has a pretrained model loaded if you want to look</p>

<p><img src="ProgramSS.png" alt="Program" width="400" /></p>

<p><img src="UML.png" alt="UML Diagram" width="800" /></p>

<p>Reason for project - wanted to better understand the underlying operations of a machine learning models, instead of relying on prewritten libraries in tensorflow and pytorch soley</p>

<ul>
  <li>This hopefully increases my perception in debugging and all aspects of ML</li>
</ul>

<p>Current model can recognise digits 0-9 (after training has resulted in up to 97.5% accuracy on 10,000 unseen examples)</p>

<ul>
  <li>indicative of good generalisation</li>
</ul>

<p>Can reload a previously trained model or train a completely new one (up to preference)</p>

<ul>
  <li>there is a save and reload feature, otherwise it just initilises with random variables (to then be trained)</li>
</ul>

<p>Main.ipynb currently models digit recognition as per following</p>

<ul>
  <li>One neural network with three hidden layers
    <ul>
      <li>DenseLayer(units=25, act_fun=relu)</li>
      <li>DenseLayer(units=15, act_fun=relu)</li>
      <li>DenseLayer(units=10, act_fun=linear)</li>
    </ul>
  </li>
  <li>The reason the final layer is linear and not softmax is to minimise round off error that can occur (softmax conversion occurs after using the linear output)
    <ul>
      <li>please note softmax values are used in back propogation (even for linear layer)</li>
    </ul>
  </li>
  <li>loss function is sparse categorical cross entropy
    <ul>
      <li>code for this function can be found in /src/loss_functions</li>
    </ul>
  </li>
</ul>

<p>NeuralNetwork class - see UML diagram for function overview/description</p>

<ul>
  <li>custom, adaptable class (hosts hidden layers)</li>
  <li>can add as many layers using what ever activation function you want</li>
  <li>IS NOT HARD CODED FOR DIGIT RECOGNITION - can do virtually anything you can adapt it too</li>
  <li>in main.ipynb just contains the customisation to work for digit recognition</li>
</ul>

<p>DenseLayer class - see UML diagram for function overview/description</p>

<ul>
  <li>initalises its own weigths and biases based on initialisation</li>
  <li>can reload previously trained models</li>
  <li>a lot of back_prop and for_prop functionality occurs within this class</li>
</ul>

<p>Currently main.ipynb initalises a completely new neural network, but at the end of the document is a commented out way to load previously trained network model (if desired)</p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[Custom Neural Network Library - Implements Handwritten Digit Recognition]]></summary></entry></feed>